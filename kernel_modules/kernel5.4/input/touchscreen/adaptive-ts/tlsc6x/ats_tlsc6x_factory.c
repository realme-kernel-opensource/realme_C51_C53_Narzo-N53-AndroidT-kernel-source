#include <linux/kernel.h>
#include <linux/uaccess.h>
#include <linux/vmalloc.h>
#include <linux/fs.h>
#include <linux/delay.h>
#include <linux/slab.h>
#include "ats_core.h"
#include "ats_tlsc6x_main.h"
#ifdef CONFIG_FACTORY_TEST_EN

/***********************************************************************************************************/
#define noise_frame                     100
#define noise_max                       100

#define integral                        1
#define scale_a                         0x31
#define scale_b                         0x31
#define os_clk                          0x6302
#define m1_ratio_lower_va               30
#define m1_ratio_upper_va               30
#define m2_ratio                        40

unsigned short os_base[] = { //A511L series
926,1406,1382,1363,1340,1319,1300,1277,720,
893,1424,1403,1382,1359,1336,1314,1288,770,
1289,1843,1872,1833,1715,1684,1660,1631,943,
1116,1829,1861,1889,1661,1697,1670,1637,1109,
0,0,0,0,0,0,0,0,0,
};

unsigned short rawdata_min[] = { //A511L series
6231,5952,5730,5852,5869,5896,5891,5940,6127,
6119,5969,5747,5840,5856,5913,5910,6030,6210,
6003,5393,5288,5075,5393,5571,5581,5673,5948,
5872,5364,5162,5141,5235,5441,5503,5606,6029,
0,0,0,0,0,0,0,0,0,
};

unsigned short rawdata_max[] = { //A511L series
14539,13888,13370,13652,13693,13756,13745,13858,14295,
14277,13927,13407,13626,13664,13797,13790,14068,14490,
14005,12581,12336,11841,12583,12999,13021,13237,13876,
13700,12514,12044,11993,12215,12693,12839,13080,14067,
0,0,0,0,0,0,0,0,0,
};

unsigned short common_os_base[] = {
2000,2000,2000,2000,2000,2000,2000,2000,2000,
2000,2000,2000,2000,2000,2000,2000,2000,2000,
2000,2000,2000,2000,2000,2000,2000,2000,2000,
2000,2000,2000,2000,2000,2000,2000,2000,2000,
0,0,0,0,0,0,0,0,0,
};

unsigned short common_rawdata_min[] = {
3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,
0,0,0,0,0,0,0,0,0,
};

unsigned short common_rawdata_max[] = {
16000,16000,16000,16000,16000,16000,16000,16000,16000,
16000,16000,16000,16000,16000,16000,16000,16000,16000,
16000,16000,16000,16000,16000,16000,16000,16000,16000,
16000,16000,16000,16000,16000,16000,16000,16000,16000,
0,0,0,0,0,0,0,0,0,
};

#define MAX_SCAP_ROW                              5
#define MAX_SCAP_COL                              20
#define MAX_SCAP_CHANNEL                          48
#define MAX_CAP_DATA_SIZE                        (MAX_SCAP_ROW * MAX_SCAP_COL * 2)
#define SAVE_LOG_NAME                            "/sdcard/factory_test_result.txt"
#define tlsc_log_file(fmt, ...) do{ memset(gFactory.catch_buffer, 0, sizeof(gFactory.catch_buffer)); sprintf(gFactory.catch_buffer, fmt, ##__VA_ARGS__); tlsc_log_file_imp(gFactory.catch_buffer); }while(0)


#define MAX_IX_NUM_3536                           12
#define MAX_CHANNEL_ONE_GROUP                     4

extern struct tlsc6x_data *g_tp_drvdata;
extern struct i2c_client *g_tlsc6x_client;
extern int tlsc6x_write_bytes_u16addr(struct i2c_client *client, u16 addr, u8 *txbuf, u16 len);
extern int tlsc6x_read_bytes_u16addr(struct i2c_client *client, u16 addr, u8 *rxbuf, u16 len);
extern int tlsc6x_download_ramcode(u8* pcode, u16 len);

struct factory_test_init
{
    unsigned char rowsCnt;
    unsigned char colsCnt;
    unsigned char keyCnt;

    unsigned short sensor_2_ic_map[MAX_SCAP_CHANNEL];
    unsigned short ic_2_sensor_map[MAX_SCAP_CHANNEL];
    char catch_buffer[100];
    unsigned char read_buffer[204];

    struct file * file;
    loff_t pos;
};

struct factory_test_range{
	int tp_vendor_id;
	int tp_project_id;
	int os_base_len;
	unsigned short *os_base;
	unsigned short *rawdata_min;
	unsigned short *rawdata_max;
};

static struct factory_test_range g_range_select;

static struct factory_test_range range_select[] = {
{
	.tp_vendor_id = 0x1d,    //W5006S
	.tp_project_id = 0x20,
	.os_base_len = 45,
	.os_base = common_os_base,
	.rawdata_min = common_rawdata_min,
	.rawdata_max = common_rawdata_max
},
{
	.tp_vendor_id = 0,    //0 is not zero, the previous project will not be modified
	.tp_project_id = 0,
	.os_base_len = 45,
	.os_base = os_base,
	.rawdata_min = rawdata_min,
	.rawdata_max = rawdata_max
},
{
	.tp_vendor_id = -1,    //reserved
	.tp_project_id = -1,
	.os_base_len = 45,
	.os_base = common_os_base,
	.rawdata_min = common_rawdata_min,
	.rawdata_max = common_rawdata_max
},
};

static struct factory_test_init gFactory;
static const unsigned char os_boot_3536[] = {
0x08,0x80,0x36,0x35,0x0C,0x02,0x5C,0x07,0x4B,0x4E,0x4C,0x54,0x80,0x00,0x88,0x00,
0x3C,0x80,0xC0,0x46,0x00,0xA0,0x19,0x09,0x19,0x0A,0x08,0x50,0x04,0xB1,0x91,0x02,
0xFB,0xCB,0x0C,0x08,0xC0,0x6B,0x0D,0x08,0x85,0x06,0x0B,0x08,0xC0,0x6B,0x0C,0x08,
0x85,0x06,0x0C,0x09,0x40,0xA0,0x08,0x40,0x40,0xA0,0x48,0x40,0x0C,0x09,0x0D,0x0A,
0x0D,0x0B,0x08,0x58,0x10,0x50,0x04,0xB1,0x04,0xB2,0x9A,0x02,0xF9,0xCB,0x00,0x90,
0x27,0x98,0xC0,0x46,0x12,0x00,0x00,0x00,0x13,0x00,0x00,0x00,0xAC,0x9C,0x80,0x00,
0xAC,0x9B,0x80,0x00,0x0C,0x06,0x80,0x00,0x00,0x84,0x80,0x00,0x00,0x85,0x80,0x00,
0x54,0x07,0x00,0x00,0x04,0x8D,0x80,0x00,0x0C,0x8D,0x80,0x00,0x00,0x88,0x80,0x00,
0x00,0xA0,0x80,0x00,0xCE,0xFA,0xAD,0xDE,0x54,0x95,0x80,0x00,0x10,0x65,0x92,0xE0,
0x00,0xA3,0x02,0x80,0x10,0xD9,0x10,0xD0,0x01,0xB3,0x93,0x02,0xFA,0xCB,0x10,0x6D,
0xF0,0x65,0x46,0x0A,0xFF,0xA3,0x13,0x40,0x45,0x0B,0x55,0xA1,0x19,0x40,0x45,0x09,
0x00,0xA3,0x45,0x0F,0x0B,0x40,0x13,0x40,0x02,0xA2,0x3A,0x40,0x43,0x0A,0x13,0x20,
0x43,0x0B,0x08,0xA2,0x1A,0x40,0x43,0x0A,0x04,0xBB,0x1A,0x20,0x42,0x0B,0x43,0x09,
0x1B,0x28,0x5A,0xE8,0x11,0x48,0x84,0x60,0x41,0x0C,0x01,0x31,0x00,0xA0,0x19,0xE9,
0x84,0x06,0x08,0x48,0x3F,0x0E,0x00,0x30,0x99,0xE9,0x09,0x48,0x3E,0x08,0x02,0x31,
0x19,0xE8,0x09,0x48,0x3D,0x0E,0x03,0x31,0x61,0x06,0x31,0x40,0x3C,0x0D,0x3D,0x09,
0x3D,0x0C,0x00,0x38,0x29,0x20,0x01,0xA1,0x21,0x40,0x53,0xA8,0x22,0xC1,0x01,0x38,
0x46,0xA8,0x1F,0xC1,0x62,0x06,0x3A,0x40,0x31,0x40,0x03,0x3E,0x02,0x38,0x32,0xF2,
0x12,0xE8,0x36,0x0E,0x2A,0x20,0x9A,0xE9,0x10,0x48,0x35,0x0A,0x01,0xBE,0x10,0x20,
0x9D,0xE9,0x2D,0x48,0x00,0xF2,0x28,0xE8,0x10,0x20,0x27,0x08,0x1A,0xE8,0x12,0x48,
0x22,0x40,0x30,0x0A,0x9B,0xE8,0x1A,0x48,0x2F,0x0B,0x1A,0x40,0x00,0xAA,0x2E,0xC1,
0x19,0x40,0x2C,0x80,0x00,0x3B,0x42,0xAB,0x21,0xC1,0x01,0x3C,0x41,0xAC,0x1E,0xC1,
0x08,0xA0,0x6E,0x06,0x29,0x0B,0x86,0x1D,0x0C,0xA1,0x68,0x06,0x1E,0x40,0x08,0x1C,
0x27,0x0B,0x18,0x40,0x24,0x0B,0x11,0x49,0x19,0x40,0x1D,0x0B,0xD1,0x49,0x19,0x20,
0x92,0x49,0x09,0xF2,0x52,0xE8,0x12,0xF4,0x12,0xFC,0x1A,0x20,0x01,0xBA,0x12,0xF4,
0x20,0x09,0x12,0xFC,0x8A,0x02,0x0A,0xC9,0x16,0x0A,0x1A,0x20,0x07,0x80,0x1C,0x0A,
0x31,0xA3,0x13,0x40,0x19,0x0A,0x13,0x40,0x17,0x0B,0x01,0xA2,0x1A,0x40,0x00,0x90,
0xA1,0x99,0x00,0x90,0x1F,0x99,0x00,0x90,0x91,0x99,0xFC,0x87,0x61,0x00,0x80,0x00,
0x10,0x04,0x80,0x00,0x20,0x06,0x80,0x00,0x68,0x00,0x80,0x00,0x84,0x8D,0x80,0x00,
0x86,0x00,0x80,0x00,0x07,0x08,0x00,0x00,0x06,0x80,0x80,0x00,0x00,0x80,0x80,0x00,
0x01,0x80,0x80,0x00,0x02,0x80,0x80,0x00,0x03,0x80,0x80,0x00,0x81,0x8D,0x80,0x00,
0x7A,0x8D,0x80,0x00,0x02,0x63,0x00,0x00,0x80,0x8D,0x80,0x00,0x05,0x80,0x80,0x00,
0x74,0x8D,0x80,0x00,0x07,0x80,0x80,0x00,0x78,0x8D,0x80,0x00,0x77,0x8D,0x80,0x00,
0x76,0x8D,0x80,0x00,0xFD,0xFF,0x00,0x00,0xF0,0x65,0x28,0x0B,0x1B,0x48,0x82,0x60,
0x00,0xAB,0x49,0xC0,0x26,0x0B,0x18,0x28,0xFF,0xA3,0x1B,0xF2,0x02,0xEC,0x1A,0x00,
0x9A,0x02,0x41,0xC1,0x23,0x0B,0x1A,0x28,0xF0,0xA3,0x00,0xF6,0x1B,0xF2,0x00,0xFE,
0x9A,0x02,0x02,0xC0,0x20,0x0B,0x1C,0x58,0x00,0x80,0x20,0x0C,0x05,0xEC,0x30,0xA8,
0x00,0xC9,0x30,0xA5,0x1C,0x0B,0x2D,0xF6,0x2D,0xFE,0x59,0x58,0x6E,0xF0,0x00,0xA2,
0x00,0xA3,0x07,0x80,0xA7,0x1A,0x0F,0x20,0xA7,0x1A,0xDB,0xE9,0x1B,0xF4,0x1B,0xFC,
0x02,0xB2,0x02,0xB1,0xB2,0x02,0xF5,0xC1,0x13,0x0A,0x52,0x58,0x00,0xA1,0x00,0x32,
0x2A,0xEC,0x13,0x0D,0x0E,0x80,0x00,0x3E,0x36,0xE9,0x01,0x36,0x4E,0xF0,0x77,0x1B,
0x01,0x3C,0x27,0x20,0x74,0x1B,0x01,0xB2,0xE3,0xE8,0x1B,0xF4,0x12,0xF6,0x1B,0xFC,
0x12,0xFE,0x01,0xB1,0x54,0xF0,0x82,0x02,0xED,0xC3,0x07,0x0A,0x52,0x58,0x14,0xE9,
0x23,0x20,0x02,0x0B,0x00,0xA2,0x1A,0x20,0x02,0x60,0xF0,0x6D,0x24,0x9F,0x80,0x00,
0x20,0x9F,0x80,0x00,0x22,0x9F,0x80,0x00,0x04,0x8D,0x80,0x00,0x8C,0x8D,0x80,0x00,
0x84,0x8D,0x80,0x00,0x70,0x07,0x70,0x65,0x3D,0x0B,0x1A,0x28,0x01,0xAA,0x21,0xC0,
0x00,0xAA,0x05,0xC0,0x02,0xAA,0x5E,0xC0,0x00,0xA2,0x1A,0x20,0x5A,0x20,0x70,0x6D,
0x59,0x28,0x00,0xA9,0x5D,0xC1,0x37,0x08,0x66,0xA4,0x9A,0x28,0x04,0x40,0x36,0x08,
0x01,0x40,0x0B,0xAA,0x06,0xC8,0x01,0xA1,0x91,0x00,0xC9,0x03,0x09,0xF5,0x33,0x0A,
0x09,0xFD,0x11,0x20,0x32,0x09,0x01,0xA2,0x02,0xA0,0x08,0x40,0x5A,0x20,0x31,0x0B,
0x1A,0x40,0xE4,0x87,0x9A,0x28,0x0B,0xAA,0x3A,0xC8,0x2F,0x08,0x2F,0x09,0x00,0x58,
0x54,0xF0,0x92,0xF0,0x55,0x18,0x04,0xE9,0x80,0xA2,0x26,0x28,0x12,0xF1,0x55,0xEB,
0x75,0xE9,0x2D,0xF4,0x2D,0xFC,0x25,0x20,0x9D,0x28,0x0C,0xB5,0x6C,0xF0,0xAD,0xF0,
0x6D,0x18,0x04,0xE9,0x26,0x28,0x55,0xEB,0x75,0xE9,0x2D,0xF4,0x2D,0xFC,0x25,0x20,
0x9D,0x28,0x18,0xB5,0x6C,0xF0,0xAD,0xF0,0x6D,0x18,0x04,0xE9,0x26,0x28,0x55,0xEB,
0x75,0xE9,0x2D,0xF4,0x2D,0xFC,0x25,0x20,0x9C,0x28,0x24,0xB4,0x65,0xF0,0xA4,0xF0,
0x64,0x18,0x40,0xE9,0x01,0x28,0x12,0xEB,0x8A,0xE8,0x12,0xF4,0x12,0xFC,0x02,0x20,
0x9A,0x28,0x0B,0xAA,0x04,0xC8,0x16,0x09,0x01,0xB2,0x00,0xA0,0x08,0x20,0x9A,0x20,
0x02,0xA2,0x1A,0x20,0xA3,0x87,0x9A,0x28,0x0C,0xAA,0x0E,0xC0,0x03,0xA2,0x1A,0x20,
0x9D,0x87,0x0B,0x09,0x09,0x48,0x88,0xF7,0x00,0xC4,0x98,0x87,0x5A,0x20,0x01,0xA2,
0x1A,0x20,0x05,0x0B,0x08,0xA2,0x1A,0x40,0x91,0x87,0x0D,0xA2,0x9A,0x20,0xED,0x87,
0x0C,0x8D,0x80,0x00,0x0F,0x04,0x80,0x00,0x83,0x00,0x80,0x00,0x0A,0x04,0x80,0x00,
0x09,0x02,0x80,0x00,0x00,0x02,0x80,0x00,0x04,0x8D,0x80,0x00,0xEC,0x8D,0x80,0x00,
0x84,0x8D,0x80,0x00,0xF0,0x65,0x2E,0x0B,0x00,0xA1,0x18,0x58,0x18,0xA2,0x00,0x90,
0x03,0x99,0x00,0xA5,0x2B,0x0F,0x2C,0x0C,0x00,0xA6,0x09,0x80,0x66,0x20,0x26,0x20,
0xA6,0x20,0xFF,0x97,0x60,0x9F,0x28,0x0A,0x93,0x28,0x0B,0xAB,0xF9,0xC9,0x01,0xB5,
0x3B,0x48,0x9D,0x02,0xF2,0xCB,0x22,0x0B,0x24,0x08,0x19,0x58,0x60,0xA2,0xFF,0x97,
0x2D,0x9E,0x23,0x0B,0x1B,0x48,0x00,0xAB,0x04,0xC0,0x22,0x0B,0x1A,0x28,0x22,0x0B,
0x1A,0x20,0x09,0x80,0x21,0x0B,0x1B,0x48,0x00,0xAB,0x2F,0xC0,0x20,0x0A,0x13,0x40,
0x20,0x0B,0x1A,0x48,0x20,0x0B,0x1A,0x40,0x15,0x0B,0x00,0xA1,0x18,0x58,0x18,0xA2,
0x00,0x90,0xD2,0x98,0x00,0xA5,0x13,0x0F,0x13,0x0C,0x00,0xA6,0x09,0x80,0x66,0x20,
0x26,0x20,0xA6,0x20,0xFF,0x97,0x2F,0x9F,0x0F,0x0A,0x93,0x28,0x0B,0xAB,0xF9,0xC9,
0x01,0xB5,0x3B,0x48,0x9D,0x02,0xF2,0xCB,0x0D,0x0B,0x1B,0x48,0x00,0xAB,0x0D,0xC1,
0x07,0x0B,0x0A,0x09,0x18,0x58,0x00,0xA3,0xC2,0xE8,0xCC,0x1A,0x15,0x28,0x2C,0xEB,
0x64,0xF4,0x24,0xFC,0x02,0xB3,0x14,0x20,0x60,0xAB,0xF5,0xC1,0xF0,0x6D,0xC0,0x46,
0x04,0x8D,0x80,0x00,0x80,0x8D,0x80,0x00,0x0C,0x8D,0x80,0x00,0x8C,0x8D,0x80,0x00,
0x81,0x8D,0x80,0x00,0x74,0x8D,0x80,0x00,0x02,0x02,0x80,0x00,0x77,0x8D,0x80,0x00,
0x0D,0x04,0x80,0x00,0x78,0x8D,0x80,0x00,0x04,0x02,0x80,0x00,0x00,0x65,0x03,0x0A,
0x03,0x0B,0x1A,0x20,0xFF,0x97,0x98,0x9E,0x00,0x6D,0xC0,0x46,0x06,0x63,0x00,0x00,
0x84,0x8D,0x80,0x00,0x10,0x65,0x30,0x0B,0xF0,0xA2,0x1A,0x40,0x00,0xA2,0x06,0xB3,
0x1A,0x40,0x04,0xA1,0x03,0xB3,0x19,0x40,0x2C,0x09,0x0A,0x20,0x2C,0x0A,0x57,0xA1,
0x11,0x40,0x00,0xA3,0x02,0xB2,0x2B,0x09,0x13,0x40,0x13,0xA2,0x0A,0x40,0x01,0xB9,
0x0B,0x40,0x02,0xA4,0x02,0xB1,0x0C,0x40,0x01,0xB1,0x0A,0x40,0x26,0x0A,0x13,0x40,
0x07,0xB2,0x13,0x40,0x0A,0xB2,0x13,0x40,0x24,0x0A,0x13,0x40,0x24,0x0B,0x01,0xA2,
0x1A,0x40,0x24,0x0A,0x24,0x0B,0x12,0xF4,0x12,0xFC,0x1A,0x20,0x23,0x08,0xF0,0xA2,
0x00,0xA1,0x00,0x90,0x59,0x98,0x22,0x0B,0x82,0xA2,0x1A,0x40,0x9F,0xB3,0xFF,0xB3,
0x1C,0x40,0x20,0x0B,0x1A,0x48,0x20,0x0B,0x1A,0x40,0x20,0x0B,0x1A,0x28,0x20,0x0B,
0x1A,0x20,0x20,0x0A,0xFC,0xA3,0x9B,0xF1,0x13,0x20,0x1F,0x0B,0x1B,0x48,0x00,0xAB,
0x02,0xC1,0x1E,0x0B,0x1B,0x48,0x13,0x40,0x1D,0x0B,0x03,0xA2,0x1A,0x40,0x16,0xA2,
0x0D,0xB3,0x1A,0x40,0x61,0xA2,0x04,0xB3,0x1A,0x40,0x0E,0xBB,0x02,0xA2,0x1A,0x40,
0x18,0x0B,0x1B,0x48,0x01,0xAB,0x06,0xC1,0x0F,0x0B,0x21,0xA2,0x1A,0x40,0x13,0x0B,
0x1A,0x48,0x10,0x0B,0x1A,0x40,0x10,0x6D,0x00,0x04,0x80,0x00,0x0A,0x04,0x80,0x00,
0x0C,0x04,0x80,0x00,0x0C,0x02,0x80,0x00,0x01,0x02,0x80,0x00,0x15,0x04,0x80,0x00,
0x16,0x04,0x80,0x00,0xEC,0x8D,0x80,0x00,0x14,0x02,0x80,0x00,0x00,0xE0,0x80,0x00,
0x6B,0x00,0x80,0x00,0x76,0x8D,0x80,0x00,0x0D,0x04,0x80,0x00,0x7A,0x8D,0x80,0x00,
0x02,0x02,0x80,0x00,0x04,0x02,0x80,0x00,0x77,0x8D,0x80,0x00,0x78,0x8D,0x80,0x00,
0x06,0x02,0x80,0x00,0x81,0x8D,0x80,0x00,0x00,0xA3,0x01,0x80,0x02,0xD0,0x01,0xB3,
0x93,0x02,0xFB,0xCB,0x70,0x07,0x00,0x00,0x04,0x0A,0x05,0x0B,0x10,0x58,0x11,0x58,
0x0B,0x00,0x13,0x50,0x80,0xA3,0x5B,0xF4,0x18,0x00,0x70,0x07,0x40,0x06,0x80,0x00,
0xFF,0xFF,0xFF,0xFE,0x04,0x0A,0x80,0xA3,0x10,0x58,0x11,0x58,0x5B,0xF4,0x19,0x03,
0x18,0x00,0x11,0x50,0x70,0x07,0xC0,0x46,0x40,0x06,0x80,0x00,0x10,0x65,0x07,0x0B,
0x07,0x09,0x1A,0x58,0x1C,0x58,0x21,0x00,0x19,0x50,0x19,0x58,0x08,0x03,0x18,0x50,
0x80,0xA3,0x5B,0xF4,0x10,0xEC,0x18,0x00,0x10,0x6D,0xC0,0x46,0x40,0x06,0x80,0x00,
0xFF,0xFF,0xFF,0xFE,0x06,0x0B,0x1A,0x58,0x00,0xA2,0x1A,0x50,0x08,0xBB,0x19,0x58,
0x1A,0x50,0x04,0x0B,0x19,0xEC,0x60,0xB1,0x04,0xD3,0x8B,0x02,0xFC,0xC1,0x70,0x07,
0x48,0x06,0x80,0x00,0x14,0x8D,0x80,0x00,0x03,0x0B,0x01,0xA1,0x1A,0x58,0x81,0x00,
0x08,0xEC,0x10,0x03,0x18,0x50,0x70,0x07,0x40,0x06,0x80,0x00,0x02,0xA8,0x06,0xCC,
0x80,0xA3,0x5B,0xF4,0x83,0x00,0x08,0x0A,0x1B,0xFE,0x13,0x40,0x0A,0x80,0x06,0xA8,
0x03,0xC1,0x06,0x0B,0x14,0xA2,0x1A,0x40,0x04,0x80,0x01,0xA3,0x83,0x00,0x18,0xEC,
0x03,0x0B,0x18,0x50,0x70,0x07,0xC0,0x46,0x23,0x06,0x80,0x00,0x22,0x00,0x80,0x00,
0x48,0x06,0x80,0x00,0xF0,0x65,0x0C,0x0B,0x1E,0x58,0x08,0xBB,0x1B,0x58,0x0B,0x0D,
0x1E,0x00,0x00,0xA4,0x01,0xA7,0x3B,0xEC,0xA3,0x00,0x1E,0x02,0x07,0xC0,0x2B,0x58,
0x00,0xAB,0x01,0xC0,0x00,0x90,0x24,0x98,0x20,0xEC,0xFF,0x97,0xCF,0x9F,0x01,0xB4,
0x04,0xB5,0x18,0xAC,0xEF,0xC1,0xF0,0x6D,0x48,0x06,0x80,0x00,0x14,0x8D,0x80,0x00,
0x30,0x65,0x0D,0xEC,0x04,0xEC,0xFF,0x97,0x77,0x9F,0x03,0x0B,0xA4,0xF0,0xE5,0x10,
0xFF,0x97,0x8C,0x9F,0x30,0x6D,0xC0,0x46,0x14,0x8D,0x80,0x00,0x00,0xA3,0x17,0xA8,
0x02,0xC8,0x02,0x0B,0x80,0xF0,0xC3,0x18,0x18,0xEC,0x70,0x07,0x14,0x8D,0x80,0x00,
0x18,0x07,0xC0,0x46,0x10,0x9D,0x80,0x00,0x26,0x9F,0x80,0x00,
};

void tlsc_log_file_imp(char* sztext)
{
    #if 0  // Not support use VFS out of kernel
    mm_segment_t old_fs;

    old_fs = get_fs();
	set_fs(KERNEL_DS);

    if(!IS_ERR(gFactory.file))
    {
        vfs_write(gFactory.file, sztext, strlen(sztext), &gFactory.pos);
    }

    set_fs(old_fs);
    #else
     if(!IS_ERR(gFactory.file))
    {
        kernel_write(gFactory.file, sztext, strlen(sztext), &gFactory.pos);
    }
    #endif

}

int fetch_one_osdata_flow(void)
{
    int ret = 0, index;
    unsigned char  sync_mark = 0x01;
    unsigned short sync_addr = 0xc000;
    unsigned short ctp_sync, sync_size = 100;

    ctp_sync = (sync_size >> 1) | 0xff00;
    ret = tlsc6x_write_bytes_u16addr(g_tlsc6x_client, 0x9f22, (unsigned char*)&sync_addr, 2);
    ret = tlsc6x_write_bytes_u16addr(g_tlsc6x_client, 0x9f20, (unsigned char*)&ctp_sync, 2);
    ret = tlsc6x_write_bytes_u16addr(g_tlsc6x_client, 0x9f24, (unsigned char*)&sync_mark, 1);

    for(index = 0; index < 50; index++)
    {
        ret = tlsc6x_read_bytes_u16addr(g_tlsc6x_client, 0x9f24, &sync_mark, 1);
        if(sync_mark > 0)
        {
            mdelay(30);
            continue;
        }
        break;
    }

    if(sync_mark > 0){
        tlsc_err("sync os data failed\n");
        return -EINVAL;
    }

    ret = tlsc6x_read_bytes_u16addr(g_tlsc6x_client, 0x9f26, gFactory.read_buffer, sync_size);

    return ret;
}

int fetch_one_rawdata_flow(void)
{
    int ret = 0, index;
    unsigned char  sync_mark = 0x01;
    unsigned short sync_addr = 0xfff0;
    unsigned short ctp_sync, sync_size = (gFactory.rowsCnt + 1) * gFactory.colsCnt * 2;

    ctp_sync = (sync_size >> 1) | 0xff00;
    ret = tlsc6x_write_bytes_u16addr(g_tlsc6x_client, 0x9f22, (unsigned char*)&sync_addr, 2);
    ret = tlsc6x_write_bytes_u16addr(g_tlsc6x_client, 0x9f20, (unsigned char*)&ctp_sync, 2);
    ret = tlsc6x_write_bytes_u16addr(g_tlsc6x_client, 0x9f24, (unsigned char*)&sync_mark, 1);

    for(index = 0; index < 50; index++)
    {
        ret = tlsc6x_read_bytes_u16addr(g_tlsc6x_client, 0x9f24, &sync_mark, 1);
        if(sync_mark > 0)
        {
            mdelay(1);
            continue;
        }
        break;
    }

    if(sync_mark > 0){
        tlsc_err("sync raw data failed\n");
        return -EINVAL;
    }

    ret = tlsc6x_read_bytes_u16addr(g_tlsc6x_client, 0x9f26, gFactory.read_buffer, sync_size);

    return ret;
}

void tlsc_print_matrix(unsigned short matrix[MAX_SCAP_ROW][MAX_SCAP_COL], int rows, int cols, int keys)
{
    int row = 0, col = 0;
    for(row = 0; row < rows + 1; row++)
    {
        for(col = 0; col < (row < rows ? cols : keys); col++)
        {
            tlsc_log_file("%-6d", matrix[row][col]);
        }
        tlsc_log_file("\r\n");
    }
    tlsc_log_file("\r\n");
}

void tlsc_print_matrix_ex(unsigned short matrix[MAX_SCAP_ROW][MAX_SCAP_COL], unsigned char invalid[MAX_SCAP_ROW][MAX_SCAP_COL], int rows, int cols)
{
    int row = 0, col = 0;
    for(row = 0; row < rows; row++)
    {
        for(col = 0; col < cols; col++)
        {
            if(1 == invalid[row][col])
                tlsc_log_file("%-6d", matrix[row][col]);
            else
                tlsc_log_file("%-6s", "/");
        }
        tlsc_log_file("\r\n");
    }
    tlsc_log_file("\r\n");
}

void reshape_data(unsigned short dataMappinged[MAX_SCAP_ROW][MAX_SCAP_COL], unsigned short* data, unsigned short len, unsigned short rows, unsigned short cols)
{
    unsigned char row, col;
    unsigned short index;

    for(row = 0; row < rows; row++)
    {
        for(col = 0; col < cols; col++)
        {
            index = (unsigned short)row * cols + col;
            if(index >= len) continue;
            dataMappinged[row][col] = data[index];
        }
    }
}

void ic_array_to_sensor_matrix(unsigned short* dataToMapping, unsigned short dataCnt, unsigned short dataMappinged[MAX_SCAP_ROW][MAX_SCAP_COL])
{
    int row, col, index, icPosition;
    memset(dataMappinged, 0, MAX_SCAP_ROW * MAX_SCAP_COL * 2);

	for(row = 0; row < gFactory.rowsCnt; row++)
	{
		for(col = 0; col < gFactory.colsCnt; col++)
		{
			index = row * gFactory.colsCnt + col;
            if(index >= sizeof(gFactory.sensor_2_ic_map) / sizeof(short))
                continue;

			icPosition = gFactory.sensor_2_ic_map[index];
			if (icPosition >= dataCnt)
				continue;
			dataMappinged[row][col] = dataToMapping[icPosition];
		}
	}
	for(index = gFactory.rowsCnt * gFactory.colsCnt; index < sizeof(gFactory.sensor_2_ic_map) / sizeof(short); index++)
	{
		col = index - gFactory.rowsCnt * gFactory.colsCnt + gFactory.colsCnt;
		icPosition = gFactory.sensor_2_ic_map[index];
		if (icPosition >= dataCnt)
			continue;
		dataMappinged[gFactory.rowsCnt][col] = dataToMapping[icPosition];
	}
}

void sensor_array_to_ic_matrix(unsigned short dataMappinged[MAX_SCAP_ROW][MAX_SCAP_COL], unsigned short* dataToMapping, unsigned short len)
{
    int row, col, index, icPosition, icRow, icCol;
    for(row = 0; row < gFactory.rowsCnt + 1; row++)
    {
        for(col = 0; col < gFactory.colsCnt; col++)
        {
            index = row * gFactory.colsCnt + col;
            if( index >= len )   continue;

            icPosition = gFactory.sensor_2_ic_map[index];
            icRow = icPosition / MAX_IX_NUM_3536;
            icCol = icPosition % MAX_IX_NUM_3536;

            dataMappinged[icRow][icCol] = dataToMapping[row * gFactory.colsCnt+ col];
        }
    }
}

int factory_test_init(char* version)
{
    int ret = 0, index, tmp;
    unsigned short *sIter;
    int i;
    //unsigned char reg[2];

    gFactory.pos = 0;
    gFactory.file = filp_open(SAVE_LOG_NAME, O_RDWR|O_CREAT|O_TRUNC, 0644);
	if(IS_ERR(gFactory.file)) {
        tlsc_err("open file %s error\n", SAVE_LOG_NAME);
        return -EINVAL;
    }else if(NULL == gFactory.file){
        tlsc_err("open file %s error\n", SAVE_LOG_NAME);
        return -EINVAL;
    }

    tlsc6x_esdHelperFreeze = 1;
    //disable_irq(g_tlsc6x_client->irq);
    ts_enable_irq_ex(g_pdata, false);

    ret = tlsc6x_set_dd_mode_sub();
    if(0 != ret){
        tlsc_err("switch to direct mode failed\n");
        return -EINVAL;
    }

    tlsc6x_read_bytes_u16addr(g_tlsc6x_client, 0x9E00, gFactory.read_buffer, 204);
    memset(gFactory.sensor_2_ic_map, 0, sizeof(gFactory.sensor_2_ic_map));
    memset(gFactory.ic_2_sensor_map, 0, sizeof(gFactory.ic_2_sensor_map));

    for(index = 0; index < MAX_SCAP_CHANNEL; index++){
        tmp = gFactory.read_buffer[22 + index];
        gFactory.ic_2_sensor_map[index] = tmp;
        if(tmp > 0){
            gFactory.sensor_2_ic_map[tmp - 1] = index;
        }
    }

    sIter = ((unsigned short*)gFactory.read_buffer) + 35;
    if(*sIter & 0x08){
        gFactory.rowsCnt = 4;
        gFactory.colsCnt = ((*sIter >> 4) & 0x3f) >> 2;
    }else{
        gFactory.rowsCnt = 2;
        gFactory.colsCnt = ((*sIter >> 4) & 0x3f) >> 1;
    }

    gFactory.keyCnt = *sIter & 0x07;
    *version = (gFactory.read_buffer[0x03] & 0xFC) >> 2;

    tlsc_log_file("row = %d, col = %d, key = %d\r\n", gFactory.rowsCnt, gFactory.colsCnt, gFactory.keyCnt);

	TS_INFO("yuhuai.yao: vendor id : 0x%x,project id : 0x%x",(g_tlsc6x_cfg_ver>>9) & 0x7F,g_tlsc6x_cfg_ver & 0x01FF);
	for(i = 0;i < ARRAY_SIZE(range_select);i++){
		if((range_select[i].tp_vendor_id == 0 && range_select[i].tp_project_id == 0) ||
			(((g_tlsc6x_cfg_ver>>9) & 0x7F) == range_select[i].tp_vendor_id && (g_tlsc6x_cfg_ver & 0x01FF) == range_select[i].tp_project_id)) {
			g_range_select = range_select[i];
			TS_INFO("yuhuai.yao:g_range_select:%x,%x,%d",g_range_select.tp_vendor_id,g_range_select.tp_project_id,g_range_select.os_base_len);
			break ;
		}
	}

    return ret;
}

int factory_test_over(void)
{
    if(!IS_ERR(gFactory.file))
    {
        filp_close(gFactory.file, NULL);
    }

    //tlsc6x_tpd_reset_force();
    ts_reset_controller_ex(ts_get_ts_data(), true);

    tlsc6x_esdHelperFreeze = 0;
    //enable_irq(g_tlsc6x_client->irq);
    ts_enable_irq_ex(g_pdata, true);

    return 0;
}

int tlsc_openshort_test(void)
{
    int failer_cnt = 0;
    int ret, index, row, col, nextRow;
    unsigned char* os_buffer = NULL;
    unsigned short *sIter, *sBase, sMax, sMin;
    unsigned int os_ab_set;
    int productLast, productNext;
    //unsigned short os_m1[MAX_SCAP_ROW][MAX_SCAP_COL] = {0};
    unsigned char  failedChannel[MAX_SCAP_ROW][MAX_SCAP_COL];
    unsigned char  osInvalidM1[MAX_SCAP_ROW][MAX_SCAP_COL];
    unsigned short osICBaseMatrix[MAX_SCAP_ROW][MAX_SCAP_COL];
    unsigned short ic_2_sensor_matrix[MAX_SCAP_ROW][MAX_SCAP_COL];
    unsigned short osSsRawDataMatrix[MAX_SCAP_ROW][MAX_SCAP_COL], osIcRawDataMatrix[MAX_SCAP_ROW][MAX_SCAP_COL];

    tlsc_log_file("\r\n------------------------------OS Test------------------------------\r\n");

    os_ab_set = integral;
	os_ab_set = ( os_ab_set << 8 ) + scale_a;
	os_ab_set = ( os_ab_set << 8 ) + scale_b;

    os_buffer = kmalloc(sizeof(os_boot_3536) + 8, GFP_KERNEL);
    memcpy(os_buffer, os_boot_3536, sizeof(os_boot_3536));
    sIter = (unsigned short*)(os_buffer + sizeof(os_boot_3536));
    *sIter++ = 0x4241;
    *sIter++ = os_ab_set & 0xffff;
    *sIter++ = (os_ab_set >> 16) & 0x01;
    *sIter++ = os_clk;

    ret = tlsc6x_download_ramcode(os_buffer, sizeof(os_boot_3536) + 8);
    kfree(os_buffer);
    if(0 != ret){
        tlsc_err("write os boot failed\n");
        return -EINVAL;
    }

    mdelay(35);
    ret = fetch_one_osdata_flow();
    if(0 != ret){
        tlsc_err("get os data failed\n");
        return -EINVAL;
    }

    //os - M1
    tlsc_log_file("\r\nOS - M1:\r\n");
    sBase = g_range_select.os_base;
    ic_array_to_sensor_matrix((unsigned short*)gFactory.read_buffer, sizeof(gFactory.read_buffer) /sizeof(unsigned short),  osSsRawDataMatrix);
    tlsc_print_matrix(osSsRawDataMatrix, gFactory.rowsCnt, gFactory.colsCnt, gFactory.keyCnt);

    for(row = 0; row < gFactory.rowsCnt; row++)
    {
        for(col = 0; col < gFactory.colsCnt; col++)
        {
            sMin = *sBase - (*sBase * m1_ratio_lower_va) / 100;
            sMax = *sBase + (*sBase * m1_ratio_upper_va) / 100;

            if(osSsRawDataMatrix[row][col] < sMin)
            {
                failer_cnt++;
                tlsc_log_file("node(%d, %d) out of range: %d\r\n", row, col, osSsRawDataMatrix[row][col]);
            }
            else if(osSsRawDataMatrix[row][col] > sMax)
            {
                failer_cnt++;
                tlsc_log_file("node(%d, %d) out of range: %d\r\n", row, col, osSsRawDataMatrix[row][col]);
            }

            sBase++;
        }
    }

    //os - M2
    tlsc_log_file("\r\nOS - M2:\r\n");
    sensor_array_to_ic_matrix(osICBaseMatrix, g_range_select.os_base, g_range_select.os_base_len);
    reshape_data(osIcRawDataMatrix, (unsigned short*)gFactory.read_buffer, MAX_SCAP_CHANNEL, MAX_CHANNEL_ONE_GROUP, MAX_IX_NUM_3536);
    reshape_data(ic_2_sensor_matrix, gFactory.ic_2_sensor_map, MAX_SCAP_CHANNEL, MAX_CHANNEL_ONE_GROUP, MAX_IX_NUM_3536);
    memset(osInvalidM1, 0, sizeof(osInvalidM1));
    memset(failedChannel, 0, sizeof(failedChannel));

    for(col = 0; col < MAX_IX_NUM_3536; col++)
    {
        //no active channel
        if( 0 == (ic_2_sensor_matrix[0][col] + ic_2_sensor_matrix[1][col] + ic_2_sensor_matrix[2][col] + ic_2_sensor_matrix[3][col] ) ) continue;

        for(row = 0; row < MAX_CHANNEL_ONE_GROUP; row++)
        {
            if(0 == ic_2_sensor_matrix[row][col]) continue;

            nextRow = row;
            for(index = 0; index < MAX_CHANNEL_ONE_GROUP; index++)
            {
                nextRow = ( nextRow + 1 ) % MAX_CHANNEL_ONE_GROUP;
                if( ic_2_sensor_matrix[nextRow][col] ) break;
            }

            osInvalidM1[row][col]   = 1;
            osInvalidM1[nextRow][col] = 1;
            productLast = osIcRawDataMatrix[row][col] * osICBaseMatrix[nextRow][col];
            productNext = osIcRawDataMatrix[nextRow][col] * osICBaseMatrix[row][col];

            //打个补丁
            if( !productLast || !productNext )  continue;

            if( productLast > productNext + (productNext * m2_ratio) / 100 )
            {
                failedChannel[row][col] = 1;
                failedChannel[nextRow][col] = 1;
            }
            else if( productNext > productLast + (productLast * m2_ratio) / 100 )
            {
                failedChannel[row][col] = 1;
                failedChannel[nextRow][col] = 1;
            }
        }
    }

    tlsc_print_matrix_ex(osIcRawDataMatrix, osInvalidM1, MAX_CHANNEL_ONE_GROUP, MAX_IX_NUM_3536);

    for(row = 0; row < MAX_CHANNEL_ONE_GROUP; row++)
    {
        for(col = 0; col < MAX_IX_NUM_3536; col++)
        {
            if(failedChannel[row][col])
            {
                failer_cnt++;
                tlsc_log_file("node(%d, %d) out of range: %d\r\n", row, col, osIcRawDataMatrix[row][col]);
            }
        }
    }

    if(failer_cnt)
    {
        tlsc_log_file("\r\nos test fail\r\n");
        return -3;
    }
    else
    {
        tlsc_log_file("\r\nos test pass\r\n");
        return 0;
    }
}

int tlsc_rawdate_test(void)
{
    int failer_cnt = 0;
    int ret, index, row, col;
    unsigned short baseMatrix[MAX_SCAP_ROW][MAX_SCAP_COL];

    tlsc_log_file("\r\n------------------------------RawData Test------------------------------\r\n");

    for(index = 0; index < 3; index++)
    {
        ret = fetch_one_rawdata_flow();
        if(0 != ret) return ret;
    }

    tlsc_log_file("\r\nScapData:\r\n");
    reshape_data(baseMatrix, (unsigned short*)gFactory.read_buffer, sizeof(gFactory.read_buffer) >> 1, gFactory.rowsCnt, gFactory.colsCnt);
    tlsc_print_matrix(baseMatrix, gFactory.rowsCnt, gFactory.colsCnt, gFactory.keyCnt);

    for(row = 0; row < gFactory.rowsCnt; row++)
    {
        for(col = 0; col < gFactory.colsCnt; col++)
        {
            if(baseMatrix[row][col] < g_range_select.rawdata_min[row * gFactory.colsCnt + col])
            {
                failer_cnt++;
                tlsc_log_file("node(%d, %d) out of range: %d\r\n", row, col, baseMatrix[row][col]);
            }
            else if(baseMatrix[row][col] > g_range_select.rawdata_max[row * gFactory.colsCnt + col])
            {
                failer_cnt++;
                tlsc_log_file("node(%d, %d) out of range: %d\r\n", row, col, baseMatrix[row][col]);
            }
        }
    }

    if(failer_cnt)
    {
        tlsc_log_file("\r\nrawdata test fail\r\n");
        return -1;
    }
    else
    {
        tlsc_log_file("\r\nrawdata test pass\r\n");
        return 0;
    }
}
int tlsc_noise_test(void)
{
    int failer_cnt = 0;
    int ret, index, row, col;
    //const int noise_test_frames = 250;
    unsigned short baseMatrix[MAX_SCAP_ROW][MAX_SCAP_COL];
    unsigned int   sumbMatrix[MAX_SCAP_ROW][MAX_SCAP_COL];
    unsigned short noiseMatrix[MAX_SCAP_ROW][MAX_SCAP_COL];
    unsigned char *rawdata_catch, *pcatch;

    tlsc_log_file("\r\n------------------------------Noise Test------------------------------\r\n");

    rawdata_catch = vmalloc(noise_frame * sizeof(gFactory.read_buffer));
    pcatch = rawdata_catch;
    for(index = 0; index < noise_frame; index++)
    {
        ret = fetch_one_rawdata_flow();
        if(0 != ret) {vfree(rawdata_catch); return ret;}

        memcpy(pcatch, gFactory.read_buffer, sizeof(gFactory.read_buffer));
        pcatch += sizeof(gFactory.read_buffer);
    }

    pcatch = rawdata_catch;
    memset(sumbMatrix, 0, sizeof(sumbMatrix));
    for(index = 0; index < noise_frame; index++)
    {
        reshape_data(baseMatrix, (unsigned short*)pcatch, sizeof(gFactory.read_buffer) >> 1, gFactory.rowsCnt, gFactory.colsCnt);
        for(row = 0; row < gFactory.rowsCnt; row++)
        {
            for(col = 0; col < gFactory.colsCnt; col++)
            {
                sumbMatrix[row][col] += baseMatrix[row][col];
            }
        }
        pcatch += sizeof(gFactory.read_buffer);
    }

    for(row = 0; row < gFactory.rowsCnt; row++)
    {
        for(col = 0; col < gFactory.colsCnt; col++)
        {
            sumbMatrix[row][col] = sumbMatrix[row][col] / noise_frame;
        }
    }

    pcatch = rawdata_catch;
    memset(noiseMatrix, 0, sizeof(noiseMatrix));
    for(index = 0; index < noise_frame; index++)
    {
        reshape_data(baseMatrix, (unsigned short*)pcatch, sizeof(gFactory.read_buffer) >> 1, gFactory.rowsCnt, gFactory.colsCnt);
        for(row = 0; row < gFactory.rowsCnt; row++)
        {
            for(col = 0; col < gFactory.colsCnt; col++)
            {
                noiseMatrix[row][col] += (baseMatrix[row][col] - sumbMatrix[row][col]) * (baseMatrix[row][col] - sumbMatrix[row][col]);
            }
        }
        pcatch += sizeof(gFactory.read_buffer);
    }

    for(row = 0; row < gFactory.rowsCnt; row++)
    {
        for(col = 0; col < gFactory.colsCnt; col++)
        {
            noiseMatrix[row][col] = noiseMatrix[row][col] / noise_frame;
        }
    }

    tlsc_log_file("\r\nNoise Data:\r\n");
    tlsc_print_matrix(noiseMatrix, gFactory.rowsCnt, gFactory.colsCnt, gFactory.keyCnt);

    for(row = 0; row < gFactory.rowsCnt; row++)
    {
        for(col = 0; col < gFactory.colsCnt; col++)
        {
            if(noiseMatrix[row][col] > noise_max)
            {
                failer_cnt++;
                tlsc_log_file("node(%d, %d) out of range: %d\r\n", row, col, noiseMatrix[row][col]);
            }
        }
    }

    vfree(rawdata_catch);

    if(failer_cnt)
    {
        tlsc_log_file("\r\nnoise test fail\r\n");
        return -2;
    }
    else
    {
        tlsc_log_file("\r\nnoise test pass\r\n");
        return 0;
    }
}
void tlsc_factory_test(char* szOut, int* len)
{
    int ret = 0;
    unsigned char fw_version = 0;
    char* szResult = szOut;

    ret = factory_test_init(&fw_version);
    szResult += sprintf(szResult, "FW Ver = %d\n", fw_version);

    if(0 == ret){
        ret = tlsc_rawdate_test();
        szResult += sprintf(szResult, "FW RawData Test %s\n", 0 == ret ? "PASS" : "FAIL");
    }

    if(0 == ret){
        ret = tlsc_noise_test();
        szResult += sprintf(szResult, "Noise Test %s\n", 0 == ret ? "PASS" : "FAIL");
    }

    if(0 == ret){
        ret = tlsc_openshort_test();
        szResult += sprintf(szResult, "Open Test %s\n", 0 == ret ? "PASS" : "FAIL");
        szResult += sprintf(szResult, "Short Test %s\n", 0 == ret ? "PASS" : "FAIL");
    }

    *len = szResult - szOut;

    factory_test_over();
}
#endif